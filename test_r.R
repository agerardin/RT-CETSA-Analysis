## So this is the first part of the R pipeline
## which massage back the data from moltenprot
## batches of 96 wells are stitched back 
## only useful data is kept

.First<-function() {
    require("ctest", quietly = TRUE)
    options(editor="vscode")
}

# install.packages('tidyverse')
# install.packages('readxl')
# install.packages('stringr')
# install.packages('drc')
# install.packages('ggthemes')
# install.packages('cowplot')
# install.packages('hrbrthemes')
# install.packages('ggpubr')
# install.packages('MESS')
# install.packages('devtools')


library(tidyverse)
library(readxl)
library(stringr)
library(drc)
library(ggthemes)
library(cowplot)
library(hrbrthemes)
library(ggpubr)
library(MESS)
library(devtools)
.First()

# plate <-read.table("/Users/antoinegerardin/RT-CETSA-Analysis/.data/output/plate.csv",header=T,sep=",")
plate <-read_csv("/Users/antoinegerardin/RT-CETSA-Analysis/.data/output/plate.csv",col_names=T, show_col_types = FALSE)
spec(plate)
head(plate)
plate

# create a dataframe with two columns (row, col) for plate of (16,24)
col_by_row <- expand.grid(row = sprintf('%.2d', 1:16), col = sprintf('%.2d', 1:24)) %>% 
# sort by row number
arrange(., row)

# write.csv(col_by_row, "test_r.csv")

import_fit_params <- function(file_path) {
    # read the excel file generated by moltenprot
    exp_param <- read_excel('./data/cleaned_expt2/Signal_resources/Signal_results.xlsx',
                sheet = 'Fit parameters') %>%
    # remove the first column Condition which is empty
    dplyr::select(-c('Condition'))
    # Reformat ID column in each exp from MoltenProt format (A1, not A01) to arrange
    # NOTE unecessary as moltenprot generate the right output already
    exp_param$ID <-
    gsub('([A-Z])(\\d)(?!\\d)', '\\10\\2\\3', exp_param$ID, perl = TRUE)
    # sort by id
    exp_param <- exp_param %>% arrange(ID)
    
    return(exp_param)
}

exp_param1 <- import_fit_params('./data/cleaned_expt1/Signal_resources/Signal_results.xlsx')
# write.csv(exp_param1, "test_exp_param1.csv")
exp_param2 <- import_fit_params('./data/cleaned_expt2/Signal_resources/Signal_results.xlsx')
# write.csv(exp_param2, "test_exp_param2.csv")
exp_param3 <- import_fit_params('./data/cleaned_expt3/Signal_resources/Signal_results.xlsx')
exp_param4 <- import_fit_params('./data/cleaned_expt4/Signal_resources/Signal_results.xlsx')

# merge results for all experiment
exp_param <- rbind(exp_param1, exp_param2, exp_param3, exp_param4)

# write.csv(exp_param, "test_exp_param.csv")

# create a col with sequential ids for indexing
# named it `well`
exp_param <- exp_param %>% rownames_to_column() %>% rename('well' = 'rowname')

# select columns we need for this analysis
exp_param <- exp_param %>%
        dplyr::select(
          c(
            'well',
            'dHm_fit',
            'Tm_fit',
            'BS_factor',
            'T_onset',
            'dG_std'
        ))

# add row col info to results (after the well column)
exp_param <- exp_param %>% bind_cols(col_by_row) %>% relocate(c('row', 'col'), .after = well) 

# NOTE why do we create well at the first place?
# remove the well column
exp_param <- exp_param %>% dplyr::select(-'well')

# NOTE Basically regenerate the battleship coordinates based on the current ordering
# Add well assignments for each plate
well_assignment <- function(df, well_num) {
  if (well_num == 96) {
    letter <- LETTERS[1:8]
    number <- c(1:12)
    number <- str_pad(number, 2, pad = '0')
    tracker <- 1
    temp_df <- tibble(well = c(1:384))
    for (val in letter) {
      for (num in number) {
        temp_df$well[tracker] <- paste(val, num, sep = '')
        tracker <- tracker + 1
      }
    }
  }
  else if (well_num == 384) {
    letter <- LETTERS[1:16]
    number <- c(1:24)
    number <- str_pad(number, 2, pad = '0')
    tracker <- 1
    temp_df <- tibble(well = c(1:384))
    for (val in letter) {
      for (num in number) {
        temp_df$well[tracker] <- paste(val, num, sep = '')
        tracker <- tracker + 1
      }
    }
  }
  message('Well assignments created for ', well_num, '-well plate.')
  df <- cbind(temp_df, df)
  return(df)
}

exp_param <- well_assignment(exp_param, 384)

write.csv(exp_param, "test_exp_param_full.csv")





